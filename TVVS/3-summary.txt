Mutation Testing:

Product Quality model: 
- Functional suitability - does it get the job done
    Completeness - Does all the specified tasks;
    Correctness - Provides correct results;
    Appropriateness - Accomplishes the task required;
- Performance efficiency - how efficient is it
    Time behaviour - Does it do things fast enough to fit the job;
    Resource utilization - Does it stay in range of available resources;
    Capacity - Maximum limits meet requirements;
- Compatibility - can it interact with other systems in the same environment
    Co-existence: Does its thing without ruining other thing's day;
    Interoperability: how well can systems interact;
- Usability - can people use it well
    Appropriateness recognizability: can people tell it's good;
    Learnability - can people learn it;
    Operability - can people use it;
    User error protection - Does it protect users against making errors;
    User interface aesthetics - is it pretty;
    Accessibility - can disabled people for example use it;
- Reliability - does it work for long
    Maturity - is it reliable under normal operation;
    Availability - is it accessible when it needs to be;
    Fault tolerance - does it work as intended even if it shit hits the fan;
    Recoverability - if said shit hits said fan, can it recover;
- Security - does it protect information
    Confidentiality - only the right people have access to the right thing;
    Integrity - prevents unauthorized access;
    Non-repudiation - proves that things happened if someone starts pointing fingers;
    Accountability - if Julio fucks up, it should tell it was his Fault;
    Authenticity - identity of subject or resource is accurate;
- Maintainability - can it adapt to changes;
- Portability - can it be used in a different environment   
    Adaptability - can it adapt to a new usage environment;
    Installability - can it be installed in a new environment;
    Replaceability - can it be replaced by another software that does the same thing;

Quality in use:
- Effectivness - does it achieve the goals accurately
- Efficiency - does it do it well with little
- Satisfaction - we don't need no
- Freedom from risk - how does it mitigate risk 
- Context coverage - can it do all of the above in the designed (and not designed) scenarios

Programmar makes an error, a defect is in the code, a failure appears on runtime.

Verification - are we building the product right;
Validation - are we building the right product;

Mutation Testing - Two or more variants of a component are executed with the same inputs, and then we see the differences;
Mutation Analysis - Determining extent that test suite can discrimination mutants;
Mutation Score - quotient between dead mutants and non-equivalent mutants;

It is well tested if all simple faults are predicted and removed, and complex faults (combinations of simple faults) are caught between tests;

Mutations are based on well defined operators that mimic typical programming errors.

Mutation testing help construct better tests.

First order mutants - seed only simple faults, generated by a single change to the program;
Higher order mutants - Combine several first order mutants;

Weak mutation coverage - shows how much of the code is traversed;
Strong mutation coverage - measures whether the code needs to be like it is to pass the tests;

Problems with mutation testing:
- High computational cost (a lot of tests are generated, too many to be computationally viable. Do fewer, do smarter, do faster);
- Trivial mutants (mutants that cannot be run, and therefore are immediately killed);
- Equivalent mutants (mutants that change nothing, a lot of human effort to track down);
- Oracle (checks and compare outputs);

